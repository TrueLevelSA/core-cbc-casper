use std::fmt::Debug;
use std::hash::Hash;

use justification::LatestMsgsHonest;
use message::CasperMsg;
use senders_weight::SendersWeight;

extern crate serde_derive;

extern crate bincode;
extern crate blake2;
extern crate itertools;
pub extern crate serde;

/// Describes an estimate, or a value of the consensus at a certain time
pub trait Estimate: Hash + Eq + Clone + Send + Sync + Debug + serde::Serialize {
    type M: CasperMsg<Estimate = Self>;

    /// Choses an estimate from a set of latest messages
    /// The finalized_msg value can be used in order not to recursively
    /// go back to the genesis
    fn mk_estimate(
        latest_msgs: &LatestMsgsHonest<Self::M>,
        finalized_msg: Option<&Self::M>,
        senders_weights: &SendersWeight<<<Self as Estimate>::M as CasperMsg>::Sender>,
        external_data: Option<<<Self::M as CasperMsg>::Estimate as Data>::Data>,
    ) -> Self;
}

/// Describes the accessory data needed for the mk_estimate
pub trait Data: From<<Self as Data>::Data> {
    type Data;

    // /// Checks whether this data is valid
    // fn is_valid(&Self::Data) -> bool;
}

impl<T: Into<Self>> Data for T {
    type Data = T;
}

pub trait Sender: Hash + Clone + Ord + Eq + Send + Sync + Debug + serde::Serialize {}

/// Define how to compare the trait type to zero
pub trait Zero<T: PartialEq> {
    const ZERO: T;

    /// returns whether or not the value is equal to zero
    fn is_zero(val: &T) -> bool {
        val == &Self::ZERO
    }
}

/// Define how to serialize an arbitrary structure into as stream of bytes.
/// The serialization can be performed with any standard or non-standard formats
/// but the **serialization MUST ensure that only one representation is valid.**
///
/// Define a content able to identifie its content with an ID. The structure must
/// be serializable with no malleability to ensure unique valid identifiers for
/// every unique valid content.
///
/// Define how to deserialize an arbitrary byte stream. **If the byte stream is not
/// the unique valid representation of the structure, deserialization MUST fail.**
///
/// ## Serialization malleability
///
/// If a structure can be represented with multiple valid byte streams, then the
/// content identifier is not anymore unique. The implementation MUST ensure only
/// one unique valid representation. To ensure non-malleability we allow deserialization
/// to fail.
pub trait Id: serde::Serialize {
    // /// Define the type of the ID generated by `getid`.
    type ID: From<[u8; 64]>;

    /// Define the hashing algorithm used to get content ID based on the serialization
    /// provided by the default `getid` method.
    fn hash(data: &[u8]) -> Self::ID {
        use blake2::{Blake2b, Digest};
        let mut res = [0u8; 64];
        res.copy_from_slice(&Blake2b::digest(data));
        Self::ID::from(res)
    }

    fn serialize(&self) -> Vec<u8> {
        bincode::serialize(self).unwrap()
    }

    fn deserialize<'z>(bin: &'z [u8]) -> Result<Self, bincode::Error>
    where
        Self: Sized + serde::Deserialize<'z>,
    {
        bincode::deserialize(bin)
    }

    /// The default method for getting the content ID is based on the serialization of
    /// the content. This method can be overriden by other mechanisms such as random
    /// or counter IDs.
    fn getid(&self) -> Self::ID {
        let ser = <Self as Id>::serialize(self);
        Self::hash(&ser[..])
    }
}
